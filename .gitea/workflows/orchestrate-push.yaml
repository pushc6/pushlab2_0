name: orchestrate-push

on:
  push:
    branches:
      - main

jobs:
  kickoff:
    runs-on: [self-hosted, linux, x64, alma]
    steps:
      - name: Emit kickoff
        run: |
          echo "kickoff: ref=${{ github.ref }} sha=${{ github.sha }}"

  validate:
    runs-on: [self-hosted, linux, x64, alma]
    container: almalinux:10
    steps:
      - name: Prep tools (dnf)
        run: |
          dnf -y makecache
          # Ensure Node.js is present for JavaScript-based actions (actions/checkout)
          dnf -y module enable nodejs:20 || true
          dnf -y install unzip curl jq git openssh-clients ca-certificates tar which nodejs

      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Terraform
        run: |
          curl -fsSL https://releases.hashicorp.com/terraform/1.7.5/terraform_1.7.5_linux_amd64.zip -o /tmp/terraform.zip
          unzip -o /tmp/terraform.zip -d /usr/local/bin
          terraform -version

      - name: Terraform fmt/validate (lab)
        run: |
          terraform -chdir=terraform/envs/lab init -backend=false
          terraform -chdir=terraform/envs/lab fmt -check
          terraform -chdir=terraform/envs/lab validate

      - name: Terraform fmt/validate (prod)
        run: |
          terraform -chdir=terraform/envs/prod init -backend=false
          terraform -chdir=terraform/envs/prod fmt -check
          terraform -chdir=terraform/envs/prod validate

  terraform:
    runs-on: [self-hosted, linux, x64, alma]
    container: almalinux:10
    needs: [validate]
    steps:
      - name: Prep tools (dnf)
        run: |
          dnf -y makecache
          # Ensure Node.js is present for JavaScript-based actions (actions/checkout)
          dnf -y module enable nodejs:20 || true
          dnf -y install unzip curl jq git openssh-clients ca-certificates tar which nodejs

      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Terraform
        run: |
          curl -fsSL https://releases.hashicorp.com/terraform/1.7.5/terraform_1.7.5_linux_amd64.zip -o /tmp/terraform.zip
          unzip -o /tmp/terraform.zip -d /usr/local/bin

      - name: Decide environment from ref (default lab)
        id: envsel
        run: |
          set -euo pipefail
          REF="${GITHUB_REF}"
          ENVIRONMENT="lab"
          case "$REF" in
            refs/heads/orchestrate-prod|refs/tags/orchestrate-prod*) ENVIRONMENT="prod" ;;
            *) ENVIRONMENT="lab" ;;
          esac
          if [ "$ENVIRONMENT" = "prod" ]; then
            echo "TF_DIR=terraform/envs/prod" >> "$GITHUB_OUTPUT"
            echo "TF_VARS=prod.tfvars" >> "$GITHUB_OUTPUT"
          else
            echo "TF_DIR=terraform/envs/lab" >> "$GITHUB_OUTPUT"
            echo "TF_VARS=lab.tfvars" >> "$GITHUB_OUTPUT"
          fi
          echo "ENVIRONMENT=$ENVIRONMENT" >> "$GITHUB_ENV"

      - name: Decide whether to apply based on ref
        run: |
          set -euo pipefail
          APPLY="false"
          case "${GITHUB_REF}" in
            refs/heads/orchestrate-apply|refs/tags/orchestrate-apply*) APPLY="true" ;;
          esac
          echo "APPLY=$APPLY" >> "$GITHUB_ENV"

      - name: Terraform init with S3-compatible backend
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: us-east-005
          AWS_EC2_METADATA_DISABLED: "true"
        run: |
          set -euo pipefail
          TF_DIR="${{ steps.envsel.outputs.TF_DIR }}"
          if [ -f "$TF_DIR/backend.s3.secrets.hcl" ]; then
            echo "Found local backend.s3.secrets.hcl; using it for init"
            terraform -chdir="$TF_DIR" init \
              -backend-config=backend.hcl \
              -backend-config=backend.s3.secrets.hcl \
              -reconfigure \
              -input=false
          else
            echo "No local backend.s3.secrets.hcl; using CI-provided AWS_* secrets"
            terraform -chdir="$TF_DIR" init \
              -backend-config=backend.hcl \
              -reconfigure \
              -input=false
          fi

      - name: Terraform plan
        env:
          TF_VAR_vsphere_user: ${{ secrets.VSPHERE_USER }}
          TF_VAR_vsphere_password: ${{ secrets.VSPHERE_PASSWORD }}
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: us-east-005
          AWS_EC2_METADATA_DISABLED: "true"
        run: |
          terraform -chdir=${{ steps.envsel.outputs.TF_DIR }} plan -var-file=${{ steps.envsel.outputs.TF_VARS }} -out=tfplan.out

      - name: Terraform apply (conditional in-shell)
        env:
          TF_VAR_vsphere_user: ${{ secrets.VSPHERE_USER }}
          TF_VAR_vsphere_password: ${{ secrets.VSPHERE_PASSWORD }}
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: us-east-005
          AWS_EC2_METADATA_DISABLED: "true"
        run: |
          if [ "${APPLY}" != "true" ]; then
            echo "APPLY=false; skipping terraform apply"
            exit 0
          fi
          terraform -chdir=${{ steps.envsel.outputs.TF_DIR }} apply -auto-approve tfplan.out
